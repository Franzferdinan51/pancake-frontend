{"ast":null,"code":"import { request, gql } from 'graphql-request';\nimport { GRAPH_API_PREDICTIONS } from 'config/constants/endpoints';\nimport { BetPosition, PredictionStatus } from 'state/types';\nimport makeBatchRequest from 'utils/makeBatchRequest';\nimport { getPredictionsContract } from 'utils/contractHelpers';\nimport { getRoundBaseFields, getBetBaseFields, getUserBaseFields } from './queries';\nexport let Result;\n\n(function (Result) {\n  Result[\"WIN\"] = \"win\";\n  Result[\"LOSE\"] = \"lose\";\n  Result[\"CANCELED\"] = \"canceled\";\n  Result[\"LIVE\"] = \"live\";\n})(Result || (Result = {}));\n\nexport const numberOrNull = value => {\n  if (value === null) {\n    return null;\n  }\n\n  const valueNum = Number(value);\n  return Number.isNaN(valueNum) ? null : valueNum;\n};\nexport const makeFutureRoundResponse = (epoch, startBlock) => {\n  return {\n    id: epoch.toString(),\n    epoch: epoch.toString(),\n    startBlock: startBlock.toString(),\n    failed: null,\n    startAt: null,\n    lockAt: null,\n    lockBlock: null,\n    lockPrice: null,\n    endBlock: null,\n    closePrice: null,\n    totalBets: '0',\n    totalAmount: '0',\n    bearBets: '0',\n    bullBets: '0',\n    bearAmount: '0',\n    bullAmount: '0',\n    position: null,\n    bets: []\n  };\n};\nexport const transformBetResponse = betResponse => {\n  const bet = {\n    id: betResponse.id,\n    hash: betResponse.hash,\n    amount: betResponse.amount ? parseFloat(betResponse.amount) : 0,\n    position: betResponse.position === 'Bull' ? BetPosition.BULL : BetPosition.BEAR,\n    claimed: betResponse.claimed,\n    user: {\n      id: betResponse.user.id,\n      address: betResponse.user.address,\n      block: numberOrNull(betResponse.user.block),\n      totalBets: numberOrNull(betResponse.user.totalBets),\n      totalBNB: numberOrNull(betResponse.user.totalBNB)\n    }\n  };\n\n  if (betResponse.round) {\n    bet.round = transformRoundResponse(betResponse.round);\n  }\n\n  return bet;\n};\nexport const transformRoundResponse = roundResponse => {\n  const {\n    id,\n    epoch,\n    failed,\n    startBlock,\n    startAt,\n    lockAt,\n    lockBlock,\n    lockPrice,\n    endBlock,\n    closePrice,\n    totalBets,\n    totalAmount,\n    bullBets,\n    bearBets,\n    bearAmount,\n    bullAmount,\n    position,\n    bets = []\n  } = roundResponse;\n\n  const getRoundPosition = positionResponse => {\n    if (positionResponse === 'Bull') {\n      return BetPosition.BULL;\n    }\n\n    if (positionResponse === 'Bear') {\n      return BetPosition.BEAR;\n    }\n\n    return null;\n  };\n\n  return {\n    id,\n    failed,\n    epoch: numberOrNull(epoch),\n    startBlock: numberOrNull(startBlock),\n    startAt: numberOrNull(startAt),\n    lockAt: numberOrNull(lockAt),\n    lockBlock: numberOrNull(lockBlock),\n    lockPrice: lockPrice ? parseFloat(lockPrice) : null,\n    endBlock: numberOrNull(endBlock),\n    closePrice: closePrice ? parseFloat(closePrice) : null,\n    totalBets: numberOrNull(totalBets),\n    totalAmount: totalAmount ? parseFloat(totalAmount) : 0,\n    bullBets: numberOrNull(bullBets),\n    bearBets: numberOrNull(bearBets),\n    bearAmount: numberOrNull(bearAmount),\n    bullAmount: numberOrNull(bullAmount),\n    position: getRoundPosition(position),\n    bets: bets.map(transformBetResponse)\n  };\n};\nexport const transformMarketResponse = marketResponse => {\n  return {\n    id: marketResponse.id,\n    paused: marketResponse.paused,\n    epoch: Number(marketResponse.epoch.epoch)\n  };\n};\nexport const makeRoundData = rounds => {\n  return rounds.reduce((accum, round) => {\n    return { ...accum,\n      [round.id]: round\n    };\n  }, {});\n};\nexport const getRoundResult = (bet, currentEpoch) => {\n  const {\n    round\n  } = bet;\n\n  if (round.failed) {\n    return Result.CANCELED;\n  }\n\n  if (round.epoch >= currentEpoch - 1) {\n    return Result.LIVE;\n  }\n\n  const roundResultPosition = round.closePrice > round.lockPrice ? BetPosition.BULL : BetPosition.BEAR;\n  return bet.position === roundResultPosition ? Result.WIN : Result.LOSE;\n};\n/**\n * Given a bet object, check if it is eligible to be claimed or refunded\n */\n\nexport const getCanClaim = bet => {\n  return !bet.claimed && (bet.position === bet.round.position || bet.round.failed === true);\n};\n/**\n * Returns only bets where the user has won.\n * This is necessary because the API currently cannot distinguish between an uncliamed bet that has won or lost\n */\n\nexport const getUnclaimedWinningBets = bets => {\n  return bets.filter(getCanClaim);\n};\n/**\n * Gets static data from the contract\n */\n\nexport const getStaticPredictionsData = async () => {\n  const {\n    methods\n  } = getPredictionsContract();\n  const [currentEpoch, intervalBlocks, minBetAmount, isPaused, bufferBlocks] = await makeBatchRequest([methods.currentEpoch().call, methods.intervalBlocks().call, methods.minBetAmount().call, methods.paused().call, methods.bufferBlocks().call]);\n  return {\n    status: isPaused ? PredictionStatus.PAUSED : PredictionStatus.LIVE,\n    currentEpoch: Number(currentEpoch),\n    intervalBlocks: Number(intervalBlocks),\n    bufferBlocks: Number(bufferBlocks),\n    minBetAmount\n  };\n};\nexport const getMarketData = async () => {\n  const response = await request(GRAPH_API_PREDICTIONS, gql`\n      query getMarketData {\n        rounds(first: 5, orderBy: epoch, orderDirection: desc) {\n          ${getRoundBaseFields()}\n        }\n        market(id: 1) {\n          id\n          paused\n          epoch {\n            epoch\n          }\n        }\n      }\n    `);\n  return {\n    rounds: response.rounds.map(transformRoundResponse),\n    market: transformMarketResponse(response.market)\n  };\n};\nexport const getRound = async id => {\n  const response = await request(GRAPH_API_PREDICTIONS, gql`\n      query getRound($id: ID!) {\n        round(id: $id) {\n          ${getRoundBaseFields()}\n          bets {\n           ${getBetBaseFields()}\n            user {\n             ${getUserBaseFields()}\n            }\n          }\n        }\n      }\n  `, {\n    id\n  });\n  return response.round;\n};\nexport const getBetHistory = async (where = {}, first = 1000, skip = 0) => {\n  const response = await request(GRAPH_API_PREDICTIONS, gql`\n      query getBetHistory($first: Int!, $skip: Int!, $where: Bet_filter) {\n        bets(first: $first, skip: $skip, where: $where) {\n          ${getBetBaseFields()}\n          round {\n            ${getRoundBaseFields()}\n          }\n          user {\n            ${getUserBaseFields()}\n          } \n        }\n      }\n    `, {\n    first,\n    skip,\n    where\n  });\n  return response.bets;\n};\nexport const getBet = async betId => {\n  const response = await request(GRAPH_API_PREDICTIONS, gql`\n      query getBet($id: ID!) {\n        bet(id: $id) {\n          ${getBetBaseFields()}\n          round {\n            ${getRoundBaseFields()}\n          }\n          user {\n            ${getUserBaseFields()}\n          } \n        }\n      }\n  `, {\n    id: betId.toLowerCase()\n  });\n  return response.bet;\n};","map":{"version":3,"sources":["/home/duckets/Documents/pancake-frontend-1/src/state/predictions/helpers.ts"],"names":["request","gql","GRAPH_API_PREDICTIONS","BetPosition","PredictionStatus","makeBatchRequest","getPredictionsContract","getRoundBaseFields","getBetBaseFields","getUserBaseFields","Result","numberOrNull","value","valueNum","Number","isNaN","makeFutureRoundResponse","epoch","startBlock","id","toString","failed","startAt","lockAt","lockBlock","lockPrice","endBlock","closePrice","totalBets","totalAmount","bearBets","bullBets","bearAmount","bullAmount","position","bets","transformBetResponse","betResponse","bet","hash","amount","parseFloat","BULL","BEAR","claimed","user","address","block","totalBNB","round","transformRoundResponse","roundResponse","getRoundPosition","positionResponse","map","transformMarketResponse","marketResponse","paused","makeRoundData","rounds","reduce","accum","getRoundResult","currentEpoch","CANCELED","LIVE","roundResultPosition","WIN","LOSE","getCanClaim","getUnclaimedWinningBets","filter","getStaticPredictionsData","methods","intervalBlocks","minBetAmount","isPaused","bufferBlocks","call","status","PAUSED","getMarketData","response","market","getRound","getBetHistory","where","first","skip","getBet","betId","toLowerCase"],"mappings":"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","sourcesContent":["import { request, gql } from 'graphql-request'\nimport { GRAPH_API_PREDICTIONS } from 'config/constants/endpoints'\nimport { Bet, BetPosition, Market, PredictionStatus, Round, RoundData } from 'state/types'\nimport makeBatchRequest from 'utils/makeBatchRequest'\nimport { getPredictionsContract } from 'utils/contractHelpers'\nimport {\n  BetResponse,\n  getRoundBaseFields,\n  getBetBaseFields,\n  getUserBaseFields,\n  RoundResponse,\n  MarketResponse,\n} from './queries'\n\nexport enum Result {\n  WIN = 'win',\n  LOSE = 'lose',\n  CANCELED = 'canceled',\n  LIVE = 'live',\n}\n\nexport const numberOrNull = (value: string) => {\n  if (value === null) {\n    return null\n  }\n\n  const valueNum = Number(value)\n  return Number.isNaN(valueNum) ? null : valueNum\n}\n\nexport const makeFutureRoundResponse = (epoch: number, startBlock: number): RoundResponse => {\n  return {\n    id: epoch.toString(),\n    epoch: epoch.toString(),\n    startBlock: startBlock.toString(),\n    failed: null,\n    startAt: null,\n    lockAt: null,\n    lockBlock: null,\n    lockPrice: null,\n    endBlock: null,\n    closePrice: null,\n    totalBets: '0',\n    totalAmount: '0',\n    bearBets: '0',\n    bullBets: '0',\n    bearAmount: '0',\n    bullAmount: '0',\n    position: null,\n    bets: [],\n  }\n}\n\nexport const transformBetResponse = (betResponse: BetResponse): Bet => {\n  const bet = {\n    id: betResponse.id,\n    hash: betResponse.hash,\n    amount: betResponse.amount ? parseFloat(betResponse.amount) : 0,\n    position: betResponse.position === 'Bull' ? BetPosition.BULL : BetPosition.BEAR,\n    claimed: betResponse.claimed,\n    user: {\n      id: betResponse.user.id,\n      address: betResponse.user.address,\n      block: numberOrNull(betResponse.user.block),\n      totalBets: numberOrNull(betResponse.user.totalBets),\n      totalBNB: numberOrNull(betResponse.user.totalBNB),\n    },\n  } as Bet\n\n  if (betResponse.round) {\n    bet.round = transformRoundResponse(betResponse.round)\n  }\n\n  return bet\n}\n\nexport const transformRoundResponse = (roundResponse: RoundResponse): Round => {\n  const {\n    id,\n    epoch,\n    failed,\n    startBlock,\n    startAt,\n    lockAt,\n    lockBlock,\n    lockPrice,\n    endBlock,\n    closePrice,\n    totalBets,\n    totalAmount,\n    bullBets,\n    bearBets,\n    bearAmount,\n    bullAmount,\n    position,\n    bets = [],\n  } = roundResponse\n\n  const getRoundPosition = (positionResponse: string) => {\n    if (positionResponse === 'Bull') {\n      return BetPosition.BULL\n    }\n\n    if (positionResponse === 'Bear') {\n      return BetPosition.BEAR\n    }\n\n    return null\n  }\n\n  return {\n    id,\n    failed,\n    epoch: numberOrNull(epoch),\n    startBlock: numberOrNull(startBlock),\n    startAt: numberOrNull(startAt),\n    lockAt: numberOrNull(lockAt),\n    lockBlock: numberOrNull(lockBlock),\n    lockPrice: lockPrice ? parseFloat(lockPrice) : null,\n    endBlock: numberOrNull(endBlock),\n    closePrice: closePrice ? parseFloat(closePrice) : null,\n    totalBets: numberOrNull(totalBets),\n    totalAmount: totalAmount ? parseFloat(totalAmount) : 0,\n    bullBets: numberOrNull(bullBets),\n    bearBets: numberOrNull(bearBets),\n    bearAmount: numberOrNull(bearAmount),\n    bullAmount: numberOrNull(bullAmount),\n    position: getRoundPosition(position),\n    bets: bets.map(transformBetResponse),\n  }\n}\n\nexport const transformMarketResponse = (marketResponse: MarketResponse): Market => {\n  return {\n    id: marketResponse.id,\n    paused: marketResponse.paused,\n    epoch: Number(marketResponse.epoch.epoch),\n  }\n}\n\nexport const makeRoundData = (rounds: Round[]): RoundData => {\n  return rounds.reduce((accum, round) => {\n    return {\n      ...accum,\n      [round.id]: round,\n    }\n  }, {})\n}\n\nexport const getRoundResult = (bet: Bet, currentEpoch: number): Result => {\n  const { round } = bet\n  if (round.failed) {\n    return Result.CANCELED\n  }\n\n  if (round.epoch >= currentEpoch - 1) {\n    return Result.LIVE\n  }\n  const roundResultPosition = round.closePrice > round.lockPrice ? BetPosition.BULL : BetPosition.BEAR\n\n  return bet.position === roundResultPosition ? Result.WIN : Result.LOSE\n}\n\n/**\n * Given a bet object, check if it is eligible to be claimed or refunded\n */\nexport const getCanClaim = (bet: Bet) => {\n  return !bet.claimed && (bet.position === bet.round.position || bet.round.failed === true)\n}\n\n/**\n * Returns only bets where the user has won.\n * This is necessary because the API currently cannot distinguish between an uncliamed bet that has won or lost\n */\nexport const getUnclaimedWinningBets = (bets: Bet[]): Bet[] => {\n  return bets.filter(getCanClaim)\n}\n\n/**\n * Gets static data from the contract\n */\nexport const getStaticPredictionsData = async () => {\n  const { methods } = getPredictionsContract()\n  const [currentEpoch, intervalBlocks, minBetAmount, isPaused, bufferBlocks] = await makeBatchRequest([\n    methods.currentEpoch().call,\n    methods.intervalBlocks().call,\n    methods.minBetAmount().call,\n    methods.paused().call,\n    methods.bufferBlocks().call,\n  ])\n\n  return {\n    status: isPaused ? PredictionStatus.PAUSED : PredictionStatus.LIVE,\n    currentEpoch: Number(currentEpoch),\n    intervalBlocks: Number(intervalBlocks),\n    bufferBlocks: Number(bufferBlocks),\n    minBetAmount,\n  }\n}\n\nexport const getMarketData = async (): Promise<{\n  rounds: Round[]\n  market: Market\n}> => {\n  const response = (await request(\n    GRAPH_API_PREDICTIONS,\n    gql`\n      query getMarketData {\n        rounds(first: 5, orderBy: epoch, orderDirection: desc) {\n          ${getRoundBaseFields()}\n        }\n        market(id: 1) {\n          id\n          paused\n          epoch {\n            epoch\n          }\n        }\n      }\n    `,\n  )) as { rounds: RoundResponse[]; market: MarketResponse }\n\n  return {\n    rounds: response.rounds.map(transformRoundResponse),\n    market: transformMarketResponse(response.market),\n  }\n}\n\nexport const getRound = async (id: string) => {\n  const response = await request(\n    GRAPH_API_PREDICTIONS,\n    gql`\n      query getRound($id: ID!) {\n        round(id: $id) {\n          ${getRoundBaseFields()}\n          bets {\n           ${getBetBaseFields()}\n            user {\n             ${getUserBaseFields()}\n            }\n          }\n        }\n      }\n  `,\n    { id },\n  )\n  return response.round\n}\n\ntype BetHistoryWhereClause = Record<string, string | number | boolean | string[]>\n\nexport const getBetHistory = async (\n  where: BetHistoryWhereClause = {},\n  first = 1000,\n  skip = 0,\n): Promise<BetResponse[]> => {\n  const response = await request(\n    GRAPH_API_PREDICTIONS,\n    gql`\n      query getBetHistory($first: Int!, $skip: Int!, $where: Bet_filter) {\n        bets(first: $first, skip: $skip, where: $where) {\n          ${getBetBaseFields()}\n          round {\n            ${getRoundBaseFields()}\n          }\n          user {\n            ${getUserBaseFields()}\n          } \n        }\n      }\n    `,\n    { first, skip, where },\n  )\n  return response.bets\n}\n\nexport const getBet = async (betId: string): Promise<BetResponse> => {\n  const response = await request(\n    GRAPH_API_PREDICTIONS,\n    gql`\n      query getBet($id: ID!) {\n        bet(id: $id) {\n          ${getBetBaseFields()}\n          round {\n            ${getRoundBaseFields()}\n          }\n          user {\n            ${getUserBaseFields()}\n          } \n        }\n      }\n  `,\n    {\n      id: betId.toLowerCase(),\n    },\n  )\n  return response.bet\n}\n"]},"metadata":{},"sourceType":"module"}