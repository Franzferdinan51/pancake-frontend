{"ast":null,"code":"/* eslint-disable no-param-reassign */\nimport { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\nimport maxBy from 'lodash/maxBy';\nimport merge from 'lodash/merge';\nimport { BIG_ZERO } from 'utils/bigNumber';\nimport { HistoryFilter, PredictionStatus } from 'state/types';\nimport { makeFutureRoundResponse, transformRoundResponse, getBetHistory, transformBetResponse, getBet, makeRoundData } from './helpers';\nconst initialState = {\n  status: PredictionStatus.INITIAL,\n  isLoading: false,\n  isHistoryPaneOpen: false,\n  isChartPaneOpen: false,\n  isFetchingHistory: false,\n  historyFilter: HistoryFilter.ALL,\n  currentEpoch: 0,\n  currentRoundStartBlockNumber: 0,\n  intervalBlocks: 100,\n  bufferBlocks: 2,\n  minBetAmount: '1000000000000000',\n  lastOraclePrice: BIG_ZERO.toJSON(),\n  rounds: {},\n  history: {},\n  bets: {}\n}; // Thunks\n\nexport const fetchBet = createAsyncThunk('predictions/fetchBet', async ({\n  account,\n  id\n}) => {\n  const response = await getBet(id);\n  const bet = transformBetResponse(response);\n  return {\n    account,\n    bet\n  };\n});\nexport const fetchRoundBet = createAsyncThunk('predictions/fetchRoundBet', async ({\n  account,\n  roundId\n}) => {\n  const betResponses = await getBetHistory({\n    user: account.toLowerCase(),\n    round: roundId\n  }); // This should always return 0 or 1 bet because a user can only place\n  // one bet per round\n\n  if (betResponses && betResponses.length === 1) {\n    const [betResponse] = betResponses;\n    return {\n      account,\n      roundId,\n      bet: transformBetResponse(betResponse)\n    };\n  }\n\n  return {\n    account,\n    roundId,\n    bet: null\n  };\n});\n/**\n * Used to poll the user bets of the current round cards\n */\n\nexport const fetchCurrentBets = createAsyncThunk('predictions/fetchCurrentBets', async ({\n  account,\n  roundIds\n}) => {\n  const betResponses = await getBetHistory({\n    user: account.toLowerCase(),\n    round_in: roundIds\n  });\n  return {\n    account,\n    bets: betResponses.map(transformBetResponse)\n  };\n});\nexport const fetchHistory = createAsyncThunk('predictions/fetchHistory', async ({\n  account,\n  claimed\n}) => {\n  const response = await getBetHistory({\n    user: account.toLowerCase(),\n    claimed\n  });\n  const bets = response.map(transformBetResponse);\n  return {\n    account,\n    bets\n  };\n});\nexport const predictionsSlice = createSlice({\n  name: 'predictions',\n  initialState,\n  reducers: {\n    setPredictionStatus: (state, action) => {\n      state.status = action.payload;\n    },\n    setHistoryPaneState: (state, action) => {\n      state.isHistoryPaneOpen = action.payload;\n      state.historyFilter = HistoryFilter.ALL;\n    },\n    setChartPaneState: (state, action) => {\n      state.isChartPaneOpen = action.payload;\n    },\n    setHistoryFilter: (state, action) => {\n      state.historyFilter = action.payload;\n    },\n    initialize: (state, action) => {\n      return { ...state,\n        ...action.payload\n      };\n    },\n    updateMarketData: (state, action) => {\n      const {\n        rounds,\n        market\n      } = action.payload;\n      const newRoundData = makeRoundData(rounds);\n      const incomingCurrentRound = maxBy(rounds, 'epoch');\n\n      if (state.currentEpoch !== incomingCurrentRound.epoch) {\n        // Add new round\n        const newestRound = maxBy(rounds, 'epoch');\n        const futureRound = transformRoundResponse(makeFutureRoundResponse(newestRound.epoch + 2, newestRound.startBlock + state.intervalBlocks));\n        newRoundData[futureRound.id] = futureRound;\n      }\n\n      state.currentEpoch = incomingCurrentRound.epoch;\n      state.currentRoundStartBlockNumber = incomingCurrentRound.startBlock;\n      state.status = market.paused ? PredictionStatus.PAUSED : PredictionStatus.LIVE;\n      state.rounds = { ...state.rounds,\n        ...newRoundData\n      };\n    },\n    setCurrentEpoch: (state, action) => {\n      state.currentEpoch = action.payload;\n    },\n    markBetAsCollected: (state, action) => {\n      const {\n        account,\n        roundId\n      } = action.payload;\n      const accountBets = state.bets[account];\n\n      if (accountBets && accountBets[roundId]) {\n        accountBets[roundId].claimed = true;\n      }\n    },\n    markPositionAsEntered: (state, action) => {\n      const {\n        account,\n        roundId,\n        bet\n      } = action.payload;\n      state.bets = { ...state.bets,\n        [account]: { ...state.bets[account],\n          [roundId]: bet\n        }\n      };\n    },\n    setLastOraclePrice: (state, action) => {\n      state.lastOraclePrice = action.payload;\n    }\n  },\n  extraReducers: builder => {\n    // Get unclaimed bets\n    builder.addCase(fetchCurrentBets.fulfilled, (state, action) => {\n      const {\n        account,\n        bets\n      } = action.payload;\n      const betData = bets.reduce((accum, bet) => {\n        return { ...accum,\n          [bet.round.id]: bet\n        };\n      }, {});\n      state.bets = merge({}, state.bets, {\n        [account]: betData\n      });\n    }); // Get round bet\n\n    builder.addCase(fetchRoundBet.fulfilled, (state, action) => {\n      const {\n        account,\n        roundId,\n        bet\n      } = action.payload;\n\n      if (bet) {\n        state.bets = { ...state.bets,\n          [account]: { ...state.bets[account],\n            [roundId]: bet\n          }\n        };\n      }\n    }); // Update Bet\n\n    builder.addCase(fetchBet.fulfilled, (state, action) => {\n      const {\n        account,\n        bet\n      } = action.payload;\n      state.history[account] = [...state.history[account].filter(currentBet => currentBet.id !== bet.id), bet];\n    }); // Show History\n\n    builder.addCase(fetchHistory.pending, state => {\n      state.isFetchingHistory = true;\n    });\n    builder.addCase(fetchHistory.rejected, state => {\n      state.isFetchingHistory = false;\n      state.isHistoryPaneOpen = true;\n    });\n    builder.addCase(fetchHistory.fulfilled, (state, action) => {\n      const {\n        account,\n        bets\n      } = action.payload;\n      state.isFetchingHistory = false;\n      state.isHistoryPaneOpen = true;\n      state.history[account] = bets; // Save any fetched bets in the \"bets\" namespace\n\n      const betData = bets.reduce((accum, bet) => {\n        return { ...accum,\n          [bet.round.id]: bet\n        };\n      }, {});\n      state.bets = merge({}, state.bets, {\n        [account]: betData\n      });\n    });\n  }\n}); // Actions\n\nexport const {\n  initialize,\n  setChartPaneState,\n  setCurrentEpoch,\n  setHistoryFilter,\n  setHistoryPaneState,\n  updateMarketData,\n  markBetAsCollected,\n  setPredictionStatus,\n  markPositionAsEntered,\n  setLastOraclePrice\n} = predictionsSlice.actions;\nexport default predictionsSlice.reducer;","map":{"version":3,"sources":["/home/duckets/Documents/pancake-frontend-1/src/state/predictions/index.ts"],"names":["createAsyncThunk","createSlice","maxBy","merge","BIG_ZERO","HistoryFilter","PredictionStatus","makeFutureRoundResponse","transformRoundResponse","getBetHistory","transformBetResponse","getBet","makeRoundData","initialState","status","INITIAL","isLoading","isHistoryPaneOpen","isChartPaneOpen","isFetchingHistory","historyFilter","ALL","currentEpoch","currentRoundStartBlockNumber","intervalBlocks","bufferBlocks","minBetAmount","lastOraclePrice","toJSON","rounds","history","bets","fetchBet","account","id","response","bet","fetchRoundBet","roundId","betResponses","user","toLowerCase","round","length","betResponse","fetchCurrentBets","roundIds","round_in","map","fetchHistory","claimed","predictionsSlice","name","reducers","setPredictionStatus","state","action","payload","setHistoryPaneState","setChartPaneState","setHistoryFilter","initialize","updateMarketData","market","newRoundData","incomingCurrentRound","epoch","newestRound","futureRound","startBlock","paused","PAUSED","LIVE","setCurrentEpoch","markBetAsCollected","accountBets","markPositionAsEntered","setLastOraclePrice","extraReducers","builder","addCase","fulfilled","betData","reduce","accum","filter","currentBet","pending","rejected","actions","reducer"],"mappings":"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","sourcesContent":["/* eslint-disable no-param-reassign */\nimport { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit'\nimport maxBy from 'lodash/maxBy'\nimport merge from 'lodash/merge'\nimport { BIG_ZERO } from 'utils/bigNumber'\nimport { Bet, HistoryFilter, Market, PredictionsState, PredictionStatus, Round } from 'state/types'\nimport {\n  makeFutureRoundResponse,\n  transformRoundResponse,\n  getBetHistory,\n  transformBetResponse,\n  getBet,\n  makeRoundData,\n} from './helpers'\n\nconst initialState: PredictionsState = {\n  status: PredictionStatus.INITIAL,\n  isLoading: false,\n  isHistoryPaneOpen: false,\n  isChartPaneOpen: false,\n  isFetchingHistory: false,\n  historyFilter: HistoryFilter.ALL,\n  currentEpoch: 0,\n  currentRoundStartBlockNumber: 0,\n  intervalBlocks: 100,\n  bufferBlocks: 2,\n  minBetAmount: '1000000000000000',\n  lastOraclePrice: BIG_ZERO.toJSON(),\n  rounds: {},\n  history: {},\n  bets: {},\n}\n\n// Thunks\nexport const fetchBet = createAsyncThunk<{ account: string; bet: Bet }, { account: string; id: string }>(\n  'predictions/fetchBet',\n  async ({ account, id }) => {\n    const response = await getBet(id)\n    const bet = transformBetResponse(response)\n    return { account, bet }\n  },\n)\n\nexport const fetchRoundBet = createAsyncThunk<\n  { account: string; roundId: string; bet: Bet },\n  { account: string; roundId: string }\n>('predictions/fetchRoundBet', async ({ account, roundId }) => {\n  const betResponses = await getBetHistory({\n    user: account.toLowerCase(),\n    round: roundId,\n  })\n\n  // This should always return 0 or 1 bet because a user can only place\n  // one bet per round\n  if (betResponses && betResponses.length === 1) {\n    const [betResponse] = betResponses\n    return { account, roundId, bet: transformBetResponse(betResponse) }\n  }\n\n  return { account, roundId, bet: null }\n})\n\n/**\n * Used to poll the user bets of the current round cards\n */\nexport const fetchCurrentBets = createAsyncThunk<\n  { account: string; bets: Bet[] },\n  { account: string; roundIds: string[] }\n>('predictions/fetchCurrentBets', async ({ account, roundIds }) => {\n  const betResponses = await getBetHistory({\n    user: account.toLowerCase(),\n    round_in: roundIds,\n  })\n\n  return { account, bets: betResponses.map(transformBetResponse) }\n})\n\nexport const fetchHistory = createAsyncThunk<{ account: string; bets: Bet[] }, { account: string; claimed?: boolean }>(\n  'predictions/fetchHistory',\n  async ({ account, claimed }) => {\n    const response = await getBetHistory({\n      user: account.toLowerCase(),\n      claimed,\n    })\n    const bets = response.map(transformBetResponse)\n\n    return { account, bets }\n  },\n)\n\nexport const predictionsSlice = createSlice({\n  name: 'predictions',\n  initialState,\n  reducers: {\n    setPredictionStatus: (state, action: PayloadAction<PredictionStatus>) => {\n      state.status = action.payload\n    },\n    setHistoryPaneState: (state, action: PayloadAction<boolean>) => {\n      state.isHistoryPaneOpen = action.payload\n      state.historyFilter = HistoryFilter.ALL\n    },\n    setChartPaneState: (state, action: PayloadAction<boolean>) => {\n      state.isChartPaneOpen = action.payload\n    },\n    setHistoryFilter: (state, action: PayloadAction<HistoryFilter>) => {\n      state.historyFilter = action.payload\n    },\n    initialize: (state, action: PayloadAction<PredictionsState>) => {\n      return {\n        ...state,\n        ...action.payload,\n      }\n    },\n    updateMarketData: (state, action: PayloadAction<{ rounds: Round[]; market: Market }>) => {\n      const { rounds, market } = action.payload\n      const newRoundData = makeRoundData(rounds)\n      const incomingCurrentRound = maxBy(rounds, 'epoch')\n\n      if (state.currentEpoch !== incomingCurrentRound.epoch) {\n        // Add new round\n        const newestRound = maxBy(rounds, 'epoch') as Round\n        const futureRound = transformRoundResponse(\n          makeFutureRoundResponse(newestRound.epoch + 2, newestRound.startBlock + state.intervalBlocks),\n        )\n\n        newRoundData[futureRound.id] = futureRound\n      }\n\n      state.currentEpoch = incomingCurrentRound.epoch\n      state.currentRoundStartBlockNumber = incomingCurrentRound.startBlock\n      state.status = market.paused ? PredictionStatus.PAUSED : PredictionStatus.LIVE\n      state.rounds = { ...state.rounds, ...newRoundData }\n    },\n    setCurrentEpoch: (state, action: PayloadAction<number>) => {\n      state.currentEpoch = action.payload\n    },\n    markBetAsCollected: (state, action: PayloadAction<{ account: string; roundId: string }>) => {\n      const { account, roundId } = action.payload\n      const accountBets = state.bets[account]\n\n      if (accountBets && accountBets[roundId]) {\n        accountBets[roundId].claimed = true\n      }\n    },\n    markPositionAsEntered: (state, action: PayloadAction<{ account: string; roundId: string; bet: Bet }>) => {\n      const { account, roundId, bet } = action.payload\n\n      state.bets = {\n        ...state.bets,\n        [account]: {\n          ...state.bets[account],\n          [roundId]: bet,\n        },\n      }\n    },\n    setLastOraclePrice: (state, action: PayloadAction<string>) => {\n      state.lastOraclePrice = action.payload\n    },\n  },\n  extraReducers: (builder) => {\n    // Get unclaimed bets\n    builder.addCase(fetchCurrentBets.fulfilled, (state, action) => {\n      const { account, bets } = action.payload\n      const betData = bets.reduce((accum, bet) => {\n        return {\n          ...accum,\n          [bet.round.id]: bet,\n        }\n      }, {})\n\n      state.bets = merge({}, state.bets, {\n        [account]: betData,\n      })\n    })\n\n    // Get round bet\n    builder.addCase(fetchRoundBet.fulfilled, (state, action) => {\n      const { account, roundId, bet } = action.payload\n\n      if (bet) {\n        state.bets = {\n          ...state.bets,\n          [account]: {\n            ...state.bets[account],\n            [roundId]: bet,\n          },\n        }\n      }\n    })\n\n    // Update Bet\n    builder.addCase(fetchBet.fulfilled, (state, action) => {\n      const { account, bet } = action.payload\n      state.history[account] = [...state.history[account].filter((currentBet) => currentBet.id !== bet.id), bet]\n    })\n\n    // Show History\n    builder.addCase(fetchHistory.pending, (state) => {\n      state.isFetchingHistory = true\n    })\n    builder.addCase(fetchHistory.rejected, (state) => {\n      state.isFetchingHistory = false\n      state.isHistoryPaneOpen = true\n    })\n    builder.addCase(fetchHistory.fulfilled, (state, action) => {\n      const { account, bets } = action.payload\n\n      state.isFetchingHistory = false\n      state.isHistoryPaneOpen = true\n      state.history[account] = bets\n\n      // Save any fetched bets in the \"bets\" namespace\n      const betData = bets.reduce((accum, bet) => {\n        return {\n          ...accum,\n          [bet.round.id]: bet,\n        }\n      }, {})\n\n      state.bets = merge({}, state.bets, {\n        [account]: betData,\n      })\n    })\n  },\n})\n\n// Actions\nexport const {\n  initialize,\n  setChartPaneState,\n  setCurrentEpoch,\n  setHistoryFilter,\n  setHistoryPaneState,\n  updateMarketData,\n  markBetAsCollected,\n  setPredictionStatus,\n  markPositionAsEntered,\n  setLastOraclePrice,\n} = predictionsSlice.actions\n\nexport default predictionsSlice.reducer\n"]},"metadata":{},"sourceType":"module"}